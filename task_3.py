"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
# ----------------------------var 1---------------------------------------

date_base = {
    'Рога и копыта': 1000000,
    'ИП Пупкин': 50000,
    'Google': 999999999,
    'Сфера': 11000,
    'Рейд': 220000}

profits = date_base.values() # O(1)
names = date_base.keys() # O(1)
lst_pr = [] # O(1)

for element in profits: # O(n)
    lst_pr.append(element) # O(1)
lst_names = [] # O(1)

for element in names: # O(n)
    lst_names.append(element) # O(1)

lst_buf = lst_pr.copy() # O(n)
lst_buf.sort(reverse=1) #O(n log n)
lst_names_buf = [] # O(1)

for element in lst_buf[:3]: # O(3)
    index = lst_pr.index(element) # O(1)
    lst_names_buf.append(lst_names[index]) # O(1)

print(lst_names_buf) # O(1)
"""
Решение тупое, в лоб. Сложность O(3n+3) так как два цикла выполнится n раз, а третий три раза,
а сложнее цикла ни чего нет в этом решении. Поэтому сложность O(n)
"""
# ----------------------------var 2---------------------------------------

date_base = {
    'Рога и копыта': 1000000,
    'ИП Пупкин': 50000,
    'Google': 999999999,
    'Сфера': 11000,
    'Рейд': 220000}

profits = date_base.values() # O(1)
names = date_base.keys() # O(1)
lst_pr = [] # O(1)
lst_names = [] # O(1)
for key, val in date_base.items(): # O(n)
    lst_pr.append(val) # O(1)
    lst_names.append(key) # O(1)

lst_buf = lst_pr.copy() # O(n)
lst_buf.sort(reverse=1) #O(n log n)
lst_names_buf = [] # O(1)

for element in lst_buf[:3]: # O(3)
    index = lst_pr.index(element) #O(1)
    lst_names_buf.append(lst_names[index]) #O(1)

print(lst_names_buf) #O(1)
"""
Решение тупое, в лоб. Сложность O(2n+3) так как первый цикл выполнится n раз
и второй  три раза, а сложнее цикла ни чего нет в этом решении. Поэтому сложность O(n)
"""
# ----------------------------var 3---------------------------------------

date_base = {
    'Рога и копыта': 1000000,
    'ИП Пупкин': 50000,
    'Google': 999999999,
    'Сфера': 11000,
    'Рейд': 220000}
list_elements = list(date_base.items())  # O(1)
list_elements.sort(key=lambda i: i[1], reverse=1)  # O(NlogN)
print(list_elements[:3]) #O(k+n) = O(n)

'''
решение оптимальное без цикла, мне кажется, сложность O(NlogN).
Правде оно будет сложнее чем предыдущие, если массив большой.
Это решение лучше, меньше строк, все задано явно. А по поводу среза не стоит переживать,
стандартная функция оптимальнее работает, чем мой велосипед в первых двух примерах.
'''
